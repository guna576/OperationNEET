This pattern serves the purpose of cloning the existing object.

Now just creating an object using class will lead to problems like missing some data of the class in cloned object because that class may contain private data.

Another issue with cloning object directly is client has to know everything about the clone class variables and methods  .( for our understanding take the client as main function)

lets go for the code for only object cloning :  
(JAVA)

class Student 
{    //there is student class
  string name;    //attributes of a student
  int age,
  private int rollno;
  Student(){}  //default constructor
  Student(string name,string age,string rollno)
    {
      this.name=name;
      this.age=age;
      this.rollno=rollno;
      }
}

class Solution
{  //this is main class
  public static void main(String arg[])
  {
  Student obj=new Student("keerthi","16",526);
  Student clonedobj=new Student();
  clonedobj.name=obj.name; //client need to remember all the attributes and methods of Base Class
  clonedobj.age=obj.age;
 clonedobj.rollno=obj.rollno;  // this line will generate error because the rollno is a private variable
  }
}

correct impelementation :


import copy


# class SelfReferencingEntity:
#     def __init__(self):
#         self.parent = None

#     def set_parent(self, parent):
#         self.parent = parent

#need to understand the selfrefernce class passed as argument by some research on this design pattern 

class SomeComponent:
    """
    Python provides its own interface of Prototype via `copy.copy` and
    `copy.deepcopy` functions. And any class that wants to implement custom
    implementations have to override `__copy__` and `__deepcopy__` member
    functions.
    """

    def __init__(self, some_int, some_list_of_objects):
        self.some_int = some_int
        self.some_list_of_objects = some_list_of_objects
        # self.some_circular_ref = some_circular_ref

    def __copy__(self):
        """
        Create a shallow copy. This method will be called whenever someone calls
        `copy.copy` with this object and the returned value is returned as the
        new shallow copy.
        """

        # First, let's create copies of the nested objects.
        some_list_of_objects = copy.copy(self.some_list_of_objects)
        # some_circular_ref = copy.copy(self.some_circular_ref)

        # Then, let's clone the object itself, using the prepared clones of the
        # nested objects.
        new = self.__class__(
            self.some_int, some_list_of_objects
        )
        new.__dict__.update(self.__dict__)

        return new

    def deepcopy(self, memo=None):
        """
        Create a deep copy. This method will be called whenever someone calls
        `copy.deepcopy` with this object and the returned value is returned as
        the new deep copy.

        What is the use of the argument `memo`? Memo is the dictionary that is
        used by the `deepcopy` library to prevent infinite recursive copies in
        instances of circular references. Pass it to all the `deepcopy` calls
        you make in the `__deepcopy__` implementation to prevent infinite
        recursions.
        """
        if memo is None:
            memo = {}

        # First, let's create copies of the nested objects.
        some_list_of_objects = copy.deepcopy(self.some_list_of_objects, memo)
        # some_circular_ref = copy.deepcopy(self.some_circular_ref, memo)

        # Then, let's clone the object itself, using the prepared clones of the
        # nested objects.
        new = self.__class__(
            self.some_int, some_list_of_objects
        )
        # __dict__ usage is The __dict__ attribute is a dictionary that contains the namespace of an object. It stores the object's attributes and their values.
        new.__dict__ = copy.deepcopy(self.__dict__, memo)

        return new


if __name__ == "__main__":

    list_of_objects = [1, {1, 2, 3}, [1, 2, 3]]
    # circular_ref = SelfReferencingEntity()
    component = SomeComponent(23, list_of_objects)
    # circular_ref.set_parent(component)

    shallow_copied_component = copy.copy(component)

    # Let's change the list in shallow_copied_component and see if it changes in
    # component.
    shallow_copied_component.some_list_of_objects.append("another object")
    if component.some_list_of_objects[-1] == "another object":
        print(
            "Adding elements to `shallow_copied_component`'s "
            "some_list_of_objects adds it to `component`'s "
            "some_list_of_objects."
        )
    else:
        print(
            "Adding elements to `shallow_copied_component`'s "
            "some_list_of_objects doesn't add it to `component`'s "
            "some_list_of_objects."
        )

    # Let's change the set in the list of objects.
    component.some_list_of_objects[1].add(4)
    if 4 in shallow_copied_component.some_list_of_objects[1]:
        print(
            "Changing objects in the `component`'s some_list_of_objects "
            "changes that object in `shallow_copied_component`'s "
            "some_list_of_objects."
        )
    else:
        print(
            "Changing objects in the `component`'s some_list_of_objects "
            "doesn't change that object in `shallow_copied_component`'s "
            "some_list_of_objects."
        )

    deep_copied_component = copy.deepcopy(component)

    # Let's change the list in deep_copied_component and see if it changes in
    # component.
    deep_copied_component.some_list_of_objects.append("one more object")
    if component.some_list_of_objects[-1] == "one more object":
        print(
            "Adding elements to `deep_copied_component`'s "
            "some_list_of_objects adds it to `component`'s "
            "some_list_of_objects."
        )
    else:
        print(
            "Adding elements to `deep_copied_component`'s "
            "some_list_of_objects doesn't add it to `component`'s "
            "some_list_of_objects."
        )

    # Let's change the set in the list of objects.
    component.some_list_of_objects[1].add(10)
    if 10 in deep_copied_component.some_list_of_objects[1]:
        print(
            "Changing objects in the `component`'s some_list_of_objects "
            "changes that object in `deep_copied_component`'s "
            "some_list_of_objects."
        )
    else:
        print(
            "Changing objects in the `component`'s some_list_of_objects "
            "doesn't change that object in `deep_copied_component`'s "
            "some_list_of_objects."
        )
    
    deep_copied_id=id(deep_copied_component.some_list_of_objects)
    original_object_id=id(component.some_list_of_objects)
    print(f"id of deep_copied_object :{deep_copied_id}")
    print(f"id of deep_copied_object : {original_object_id}")
    if(deep_copied_component==original_object_id):
        print("they are pointing to same reference")
    else:
        print(
        "^^ This shows that deepcopied objects doesnt contain same reference,")




